### 1. 브라우저 렌더링 원리

- 브라우저는 HTML, CSS, JavaScript와 같은 웹사이트에 필요한 리소스를 서버에 요청하고, 응답으로 받아온다.
- 렌더링 엔진은 전달받은 HTML과 CSS를 파싱(parsing)해 DOM(Document Object Model, 문서 객체 모델) 트리와 CSSOM(CSS Object Model, CSS 객체 모델) 트리를 만든다.
- 만들어낸 DOM 트리와 CSSOM 트리를 합쳐 **Render 트리**를 구축한다.
- Render 트리를 기반으로 **레이아웃** 과정을 통해 각 요소를 어디에 배치할 지 결정한다.
- 레이아웃 과정이 끝나면 **paint**단계를 통해 Render 트리의 각 노드를 화면상의 픽셀로 변환한다.

<br/>

- 💫 리플로우와 리페인트

다른 사이트로 이동하거나 화면에 요소가 추가, 삭제 또는 변경되는 상황이 생기면 요소의 위치와 크기를 다시 계산하고 그려야 하는데, 이러한 렌더링 과정의 레이아웃을 반복해 수행하는 것을 리플로우, 페인트 과정을 반복해 수행하는 것을 리페인트라고 한다.

<br/>

- 브라우저의 렌더링 과정에 자바스크립트는 어떻게 동작하나요?⚡️

브라우저의 렌더링 엔진이 DOM을 생성하다가 script태그나 자바스크립트 코드를 만나면 DOM 생성을 일시 중단하고 자바스크립트 엔진이 동작한다. 자바스크립트 엔진은 자바스크립트 파싱을 담당하는데, 자바스크립트 코드를 해석하여 AST(추상적 구문 트리)를 생성한다. 그리고 AST를 기반으로 인터프리터가 실행할 수 있는 중간 코드인 바이트코드를 생성하여 실행한다.

<br/>

- script 태그를 body 태그 밑에 둬야하는 이유가 있을까요?

HTML을 읽는 과정에서 script 태그를 만나면 파싱을 멈추고 스크립트 파일을 읽어 DOM 생성이 지연된다. 이 때문에 자바스크립트 코드가 무거우면 읽는 시간이 오래 걸려 화면에 표시되는 것이 지연된다.
또한, DOM 트리가 생성되기 이전에 자바스크립트가 아직 생성되지 않은 DOM의 조작을 시도할 수 있어 이러한 상황을 막기 위해 script 태그를 body 태그 밑에 둔다.

<br/>

### 2. 호이스팅에 대해 설명해보시오

변수 선언문이 코드의 선두로 끌어 올려진 것처럼 동작하는 자바스크립트 고유의 특징을 말한다.  
예를 들면 `console.log(result)`처럼 변수를 참조하는 코드가 먼저 있고 그 다음 `var result` 로 선언한 뒤 실행해보면 참조 에러가 아닌 undefined가 나온다.  
이런 현상은 자바스크립트 엔진에서 선언문이 런타임 이전에 실행되기 때문에 발생 하는 것이다.
자바스크립트는 선언만 호이스팅을 한다.  
var는 선언과 동시에 undefined로 초기화가 이루어지며, let/const는 선언과 초기화가 동시에 일어나지 않고 실행 시점에서 선언부를 만날 때 초기화가 이루어진다. 이 사이의 간격동안 변수를 참조할 수 없는데 이것을 일시적 사각지대(TDZ/Temporal Dead Zone)라고 한다. 실행 컨텍스트에 변수가 선언은 되었지만 메모리가 할당되지 않아 Reference Error가 발생한다.
변수 선언 3단계 (선언 -> 초기화 -> 할당)

- var, let, const, function, function\*, class 키워드를 사용해서 선언하는 모든 식별자(변수, 함수, 클래스등)는 호이스팅된다.  
  모든 선언문이 런타임 이전에 실행되기 때문이다.

- 참조에러(Reference Error) : 식별자를 통해 값을 참조하려 했지만 자바스크립트 엔진이 등록된 식별자를 찾을 수 없을 때 나오는 에러

<br/>

### 3. var, let, const의 차이점

var 키워드를 사용한 변수 선언은 선언 단계와 초기화 단계가 동시에 진행되고, 초기화 단계에서 undefined를 할당한다.
let과 const는 둘 다 중복 선언이 불가능하지만 let은 재할당이 가능하고 const는 재할당이 불가능하다. 둘 모두 블록 스코프를 가진다. let은 선언, 초기화, 할당 단계가 나누어 생성될 수 있지만, const는 처음 선언할 때 초기화와 할당을 함께 해주어야 한다.  
(const example // SyntaxError 변수명만 선언하고 할당을 하지 않으면 에러)

- 초기화(initialization) : 변수가 선언된 이후 최초로 값을 할당하는 것

<br/>

### 4. 클로저는 무엇인가요? 원리와 왜 사용하는지?

외부 함수보다 중첨 함수가 더 오래 유지되는 경우 중첨 함수는 이미 생명 주기가 종료한 외부 함수의 변수를 참조할 수 있다. 이러한 중첩 함수를 클로저(closure)라고 한다.

내부함수가 외부함수의 맥락(context)에 접근할 수 있는 것을 말한다.

- 클로저의 장점

1. 데이터를 보존할 수 있다.
   외부 함수의 실행이 끝나더라도 외부 함수 내 변수를 사용할 수 있다.
2. 정보의 접근 제한(캡슐화 - encapsulation)
   객체의 상태를 나타내는 프로퍼티와 프로퍼티를 참조하고 조작할 수 있는 동작인 메서드를 하나로 묶는 것을 의미
3. 모듈화에 유리
   클로저 함수를 각각의 변수에 할당하면 각자 독립적으로 값을 사용하고 보존할 수 있다.
   함수의 재사용성 : 극대화 함수를 독립적인 부품의 형태로 분리 : 모듈화

<br/>

### 5. 스코프란?

스코프는 유효범위라는 뜻으로, 식별자가 유효한 범위를 말한다.
모든 식별자는 자신이 선언된 위치에 의해 다른 코드가 식별자 자신을 참조할 수 있는 유효 범위가 결정되는데, 이를 스코프라 한다.
자바스크립트 엔진은 스코프를 통해 어떤 변수를 참조해야 할 것인지 결정한다. 따라서 스코프란 자바스크립트 엔진이 식별자를 검색할 때 사용하는 규칙이라고도 할 수 있다.

내부함수는 호출된 변수를 찾기위해 먼저 자신의 스코프에서 찾고 없으면 한단계씩 외부로 나가면서 찾는다. 이렇게 꼬리를 물고 계속 범위를 넓히면서 찾는 관계를 스코프 체인이라고 부른다.

| 구분 |         설명          |   스코프    |   변수    |
| :--: | :-------------------: | :---------: | :-------: |
| 전역 | 코드의 가장 바깥 영역 | 전역 스코프 | 전역 변수 |
| 지역 |    함수 몸체 내부     | 지역 스코프 | 지역 변수 |

<br/>

- 렉시컬 스코프란?

렉시컬 스코프는 정적 스코프를 의미하는데, 상위 스코프가 동적으로 변하지 않고 함수 정의가 평가되는 시점에 상위 스코프가 정적으로 결정되기 때문에 정적 스코프라고 부른다.  
자바스크립트는 렉시컬 스코프를 따르므로 함수를 어디서 '호출'했는지가 아니라 함수를 어디서 '정의'했는지에 따라 상위 스코프를 결정한다. 함수가 호출된 위치는 상위 스코프 결정에 어떠한 영향도 주지 않는다. 즉, 함수의 상위 스코프는 언제나 자신이 정의된 스코프다.

<br/>

### 6. 콜백이란?

콜백은 비동기 처리를 위해 사용되는 개념이다.

콜백은 함수를 다른 함수의 인자로 전달하여, 전달된 함수가 실행 완료되면 호출되는 함수이다.
일반적으로 비동기 함수가 완료되었을 때 호출되어 결과를 반환하거나, 에러를 처리하는 등의 역할을 수행한다.

콜백 함수를 사용하는 것은 프로그램의 성능과 유지보수성을 높일 수 있으나 콜백 함수 호출이 중첩되어 복잡도가 높아지는 콜백 헬이 발생할 수 있다.

Promise나 async/await 등을 콜백 지옥을 해결하는 데 사용할 수 있다.

<br/>

### 7. 프로미스란?

프로미스는 비동기 처리 상태와 처리 결과를 관리하는 객체다.  
ES6에서 비동기 처리를 위한 패턴으로 프로미스를 도입했다.  
프로미스는 전통적인 콜백 패턴이 가진 단점을 보완하며 비동기 처리 시점을 명확하게 표현할 수 있다는 장점이 있다.  
Promise 생성자 함수가 인수로 전달받은 콜백 함수 내부에서 비동기 처리를 수행한다.  
비동기 처리가 성공하면 resolve 함수를 호출하고, 비동기 처리가 실패하면 reject 함수를 호출한다.  
pending, fulfilled, rejected 3가지 상태를 가진다.

<br/>

### 8. 비동기 프로그래밍에 대해

동기 처리 방식은 태스크를 순서대로 처리해 실행 순서가 보장된다는 장점이 있지만 앞선 태스크가 종료할 때까지 이후 태스크들이 블로킹 되는 단점이 있고, 비동기 처리 방식은 현재 실행 중인 태스크가 종료되지 않아도 다음 태스크를 실행하므로 블로킹이 발생하지 않는다는 장점이 있지만 태스크의 실행 순서가 보장되지 않는 단점이 있다.

<br/>

### 9. 이벤트 루프가 뭔가요?

![call stack and heap](https://user-images.githubusercontent.com/93918946/223932686-fe84c917-6f58-4a87-9bf9-222278c38141.png)

V8 엔진을 비롯한 자바스크립트 엔진은 크게 2개의 영역으로 구분할 수 있다.

- 콜 스택  
  자바스크립트 코드가 실행되며 생성되는 실행 컨텍스트가 저장되는 자료구조.  
  함수를 호출하면 함수 실행 컨텍스트가 순차적으로 콜 스택에 푸시되고 순차적으로 실행된다.

- 힙  
  객체, 배열, 함수 등 참조 타입이 저장되는 메모리 공간.

이벤트 루프  
 콜 스택에 현재 실행 중인 실행 컨텍스트가 있는지, 그리고 태스크 큐에 대기 중인 함수가 있는지 반복해서 확인한다.  
 만약 콜 스택이 비어 있고 태스크 큐에 대기 중인 함수가 있다면 이벤트 루프는 순차적으로 태스크 큐에서 대기 중인 함수를 콜 스택으로 이동시킨다.

- 콜백 큐(테스트 큐/이벤트 큐)  
  setTimeout같은 비동기 함수의 콜백 함수 또는 이벤트 핸들러가 일시적으로 보관되는 영역이다.

<br/>

### 10. this가 뭔가요?

자신이 속한 객체 또는 자신이 생성할 인스턴스를 가리키는 자기 참조 변수

바인딩 : 식별자와 값을 연결하는 과정을 의미

| 함수 호출 방식                                             | this 바인딩                                                           |
| ---------------------------------------------------------- | --------------------------------------------------------------------- |
| 일반 함수 호출                                             | 전역 객체                                                             |
| 메서드 호출                                                | 메서드를 호출한 객체                                                  |
| 생성자 함수 호출                                           | 생성자 함수가(미래에) 생성할 인스턴스                                 |
| Function.prototype.apply/call/bind 메서드에 의한 간접 호출 | Function.prototype.apply/call/bind 메서드에 첫번째 인수로 전달한 객체 |

<br/>

### 11. 이벤트 전파에 대해 말해주세요

DOM 트리 상에 존재하는 DOM 요소 노드에서 발생한 이벤트는 DOM 트리를 통해 전파된다. 이를 이벤트 전파라고 한다.  
이벤트가 전파되는 방향에 따라 버블링과 캡쳐링으로 구분할 수 있다.  
자식 요소에서 발생한 이벤트가 부모 요소로 전파되는 것을 **버블링**이라 하고,  
자식 요소에서 발생한 이벤트가 부모 요소부터 시작하여 이벤트를 발생시킨 자식 요소까지 도달하는 것을 **캡처링**이라 한다.  
**주의할 것은 버블링과 캡처링은 둘 중에 하나만 발생하는 것이 아니라 캡처링부터 시작하여 버블링으로 종료한다**는 것이다.  
즉, 이벤트가 발생했을 때 캡처링과 버블링은 순차적으로 발생한다.

![eventflow](https://user-images.githubusercontent.com/93918946/224922454-b61d8312-7bfa-4c56-a067-c3d421b4748c.png)

<br/>

### 12. CSR과 SSR의 차이점은 무엇인가요?

SSR은 Server Side Rendering의 줄임말로, 웹 페이지를 브라우저에서 렌더링하는 대신에 서버에서 렌더링을 해서 보내는 것을 말한다. CSR은 Client Side Rendering의 줄임말로, 클라이언트가 페이지를 렌더링한다. 브라우저의 요청을 서버로 보내면 서버는 렌더링 대신, 웹 페이지와 함께 JavaScript파일을 보내고, 클라이언트가 웹 페이지를 받으면 함께 전달 받은 JavaScript 파일이 웹 페이지를 렌더링 된 페이지로 바꾼다.

SSR과 CSR의 주요 차이점은 페이지가 렌더링되는 위치이다. SSR은 서버에서 페이지를 렌더링하고, CSR은 브라우저(클라이언트)에서 페이지를 렌더링한다. CSR은 사용자가 다른 경로를 요청할 때마다 페이지를 새로고침 하지 않고, 요청한 경로에 따라 페이지를 다시 렌더링한다.

SSR 사용

- SEO(Search Engine Optimization)가 우선순위인 경우, 일반적으로 SSR을 사용한다.
- 웹 페이지의 첫 화면 렌더링이 빠르게 필요한 경우, 단일 파일의 용량이 작은 SSR 이 적합하다.
- 웹 페이지가 사용자와 상호작용이 적은 경우, SSR을 활용할 수 있다.

CSR 사용

- SEO가 우선순위가 아닌 경우, CSR을 이용할 수 있다.
- 사이트에 상호 작용등이 많이 있는 경우, CSR은 빠른 라우팅으로 더 나은 사용자 경험을 제공한다.
- 웹 애플리케이션을 제작하는 경우, CSR을 이용해 더 나은 사용자 경험(빠른 동적 렌더링 등)을 제공할 수 있다.

<br/>

### 13. 주소창에 naver.com을 입력하면 생기는 일

1. 사용자가 입력한 url 주소 중에서 도메인 네임을 DNS 서버에서 검색한다.
2. DNS 서버에서 해당 도메인 네임에 해당하는 IP주소를 찾아 사용자가 입력한 URL 정보와 함께 전달함.
3. 웹 페이지 URL + IP 주소는 HTTP 프로토콜을 사용하여 HTTP 요청 메세지를 생성한다.
4. HTTP 요청 메세지는 TCP 프로토콜을 사용하여 인터넷을 거쳐 해당 IP 주소의 컴퓨터로 전송된다.
5. 이렇게 도착한 HTTP 요청 메세지는 HTTP 프로토콜을 사용하여 웹 페이지 URL 정보로 변환된다.
6. 웹 서버는 도착한 웹 페이지 URL 정보에 해당하는 데이터를 검색한다.
7. 검색된 웹 페이지 데이터는 또다시 HTTP 프로토콜을 사용하여 HTTP 응답 메세지를 생성한다.
8. 이렇게 생성된 HTTP 응답 메세지는 TCP 프로토콜을 사용하여 인터넷을 거쳐 원래 컴퓨터로 전달된다.
9. 도착한 HTTP 응답 메세지는 HTTP 프로토콜을 이용하여 웹 페이지 데이터로 변환되고, 웹 브라우저에 의해 출력되어 사용자가 볼 수 있게 된다.

<br/>

### 14. HTTP와 HTTPS의 차이점은?

HTTP는 서버/클라이언트 모델을 따라 데이터를 주고받기 위한 프로토콜이다. HTTPS는 HTTP에 데이터 암호화가 추가된 프로토콜이다. 공개키/개인키 암호화 방식을 이용해 데이터를 암호화한다. HTTP는 암호화가 추가되지 않았기 때문에 보안에 취약한 반면, HTTPS는 안전하게 데이터를 주고받을 수 있다. 하지만 HTTPS를 이용하면 암호화/복호화 과정이 필요하기 때문에 HTTP보다 속도가 느리다.

<br/>

### 15. OOP의 특징에 대해서 설명하시오

객체지향프로그래밍은 컴퓨터 프로그래밍 패러다임 중 하나로, 프로그래밍에서 필요한 데이터를 추상화시켜 상태와 행위를 가진 객체를 만들고, 그 객체들간의 유기적인 상호작용을 통해 로직을 구성하는 프로그래밍 방법으로 OOP의 장점은 코드 재사용성이다. 클래스를 한번 만들어 놓으면 계속 이용 가능하고, 상속을 통해 확장 가능하다. 수정해야할 부분이 클래스 내부에 멤버 변수 혹은 메서드로 있기 때문에 해당 부분만 수정하면 되어 유지보수가 쉽다. 단점은 처리속도가 느리고, 객체가 많으면 용량이 커진다는 것이다. OOP의 특징으로는 클래스와 객체, 캡슐화, 상속 등이 있다. 클래스는 집단에 속하는 속성과 행위를 변수와 메서드로 정의한 것이고, 객체 즉 인스턴스는 클래스에서 정의한 것을 토대로 실제 메모리 상에 할당된 데이터이다. 상속은 부모 클래스의 속성과 기능을 그대로 이어받아 사용할 수 있게 하고, 코드의 중복을 없애기 좋다.

<br/>

### 16. useMemo vs useCallback

메모이제이션 훅으로 연산 된 값을 자료구조에 저장 후 재사용시 계산을 반복하지않고 꺼내서 사용가능하게 해준다. 메모이제이션 훅은 리액트의 불필요한 랜더링(예: 자식 컴포넌트의 상태가 변경되지않아도 랜더링 해버리는 경우)을 방지하여 퍼포먼스 최적화에 사용된다. 둘의 차이점은 useCallback은 전달된 함수 그 자체를 캐싱하지만, useMemo는 전달된 함수가 실행되고 반환된 결과를 캐싱한다는 것이다.(=useMemo는 메모이제이션 된 값을 반환하고 useCallback은 메모이제이션 된 콜백을 반환한다.)

<br/>

### 17. Async, Await란?

ES8에서 나온 async await를 사용하면 비동기 처리를 동기처럼 동작할 수 있도록 구현할 수 있다.

- async 함수는 언제나 프로미스를 반환
- async 키워드를 사용해 정의, await 키워드는 반드시 async 함수 내부에서 사용
- await 키워드는 프로미스가 settled 상태가 될 때까지 대기, settled 상태가 되면 프로미스가 resolve한 결과를 반환

<br/>

### 18. Async, Await와 Promise의 차이는?

1. 프로미스의 then/catch/finally 후속 처리 메서드에 콜백 함수를 전달해서 비동기 처리 결과를 후속 처리 할 필요가 없다.
   - async/await 활용 시 가독성이 좋다.
2. 디버그 시 Promise는 어떤 then에서 문제가 생겼는지 알기 어렵지만 async/await는 어떤 지점에서 에러가 생겼는지 알기 쉽다.
3. async/await는 try...catch로 에러 처리가 가능하다.

<br/>

### 19. ES6 문법에 추가된 것들을 아는대로 설명하세요

문자열 리터럴, 구조분해 할당, 객체 리터럴, for .. of, 스프레드 연산자, Rest Parameter, 화살표 함수, Default Params, let & const, import & export, Map & Set

<br/>

### 20. DOM 과 가상 DOM이란?

Document Object Model 의 약자로, HTML, XML 문서의 프로그래밍 인터페이스를 의미한다.  
HTML은 브라우저에서 실행될 수 있게끔 DOM Tree로 파싱되고, 이를 바탕으로 렌더링이 된다.  
가상돔은 추상화된 DOM을 뜻한다. 기존 DOM을 조작하고 렌더링하는 부분에서 오는 시간을 줄인다.  
DOM과 유사한 객체를 메모리에 올려놓고, 변경 사항이 생기면 가상돔을 바꾸고, 실제 돔에서는 변경 사항만 변경하여 더 반응성 빠른 웹을 구현할 수 있다. 리액트도 가상돔을 이용하여 구현되어있다.

<br/>

### 21. Rest API란?

REST는 HTTP를 기반으로 클라이언트가 서버의 리소스에 접근하는 방식을 규정한 아키텍처고, REST API는 REST를 기반으로 서비스 API를 구현한 것을 의미한다.  
주로 5가지 요청 메서드(GET, POST, PUT, PATCH, DELETE 등)를 사용하여 CRUD를 구현한다.

<br/>

### 22. Restful API란 무엇인가요?

RESTful - REST의 기본 원칙을 성실히 지킨 서비스 디자인을 'RESTful'이라고 표현한다.

REST에서 가장 중요한 기본적인 원칙은 두 가지다.

1. URI는 리소스를 표현하는 데 집중해야 한다.
   리소스를 식별할 수 있는 이름은 동사보다는 명사를 사용한다. 따라서 이름에 get 같은 행위에 대한 표현이 들어가서는 안 된다.

   ```javascript
   # bad
   GET /getTodos/1
   GET /todos/show/1
   # good
   GET /todos/1
   ```

2. 행위에 대한 정의는 HTTP 요청 메서드를 통해 해야 한다.

<br/>

### 23. JWT 방식을 설명하고, 왜 사용했는지?

JWT는 JSON Web Token의 약자로, 데이터가 JSON으로 이루어져 있는 토큰을 말한다. 기존의 세션인증방식은 인증 관련 정보를 세션 저장소라는 DB에 저장했기 때문에 서버가 과부하 되거나 서버를 확장하기 어려웠다. 이를 보완하기 위해( = 서버자원을 절약) 사용자 인증에 필요한 정보를 토큰 자체에 담고 있어 별도 저장소에 정보를 저장해 둘 필요가 없는 JWT을 사용하게 되었다. 토큰은 로그인 이후 서버가 만들어주는 문자열이고, 문자열 안에는 사용자의 로그인 정보와 서버의 서명이 들어있다. 사용자가 로그인을 하면 서버는 사용자에 토큰을 발급하고, 사용자는 토큰과 함께 다른 API 작업을 요청한다. 서버는 토큰의 유효성 검사를 통해 요청한 것에 대한 응답을 해준다. 단 한번 발급된 토큰은 수정 및 폐기가 불가하다는 단점이 있고, 유효기간을 짧게 지정해주는 것이 중요하다.

<br/>

### 24. CORS란? CORS를 위한 처리를 했는지, 해결 방법?

CORS는 Cross-Origin Resource Sharing의 줄임말로 다른 출처의 리소스 공유에 대한 허용/비허용 정책을 뜻한다.  
CORS 정책을 지킨 리소스 요청은 SOP 정책의 예외 사항에 들어가 다른 출처의 리소스 공유가 가능하다.  
CORS 오류를 해결하는 방법으로는

1. 서버에서 Access-Control-Allow-Origin 헤더에 알맞은 값 세팅
2. 프록시를 사용하여 우회하기

<br/>

### 25. AJAX에 대해 자세히 설명하세요(Asynchronous JavaScript and XML)

Ajax(Asynchronous JavaScript and XML)란 자바스크립트를 사용하여 브라우저가 서버에게 비동기 방식으로 데이터를 요청하고, 서버가 응답한 데이터를 수신하여 웹페이지를 동적으로 갱신하는 프로그래밍 방식을 말한다.

이전의 웹페이지는 html 태그로 시작해서 html 태그로 끝나는 완전한 HTML을 서버로부터 전송받아 웹페이지 전체를 처음부터 렌더링하는 방식으로 동작해 화면이 전환되면 새로운 HTML을 전송받아 처음부터 다시 렌더링해야 했다.  
Ajax의 등장으로 웹페이지의 변경에 필요한 데이터만 비동기 방식으로 전송받아 변경이 필요한 부분만 한정적으로 렌더링하는 방식이 가능해졌다.

<br/>

### 26. use strict 이 무엇인가요? 사용시 장단점이 무엇인가요?

"use strict";를 코드 상단에 추가하면 자바스크립트가 엄격 모드로 평가된다.

오타나 잘못된 문법 등에서 발생하는 오류를 줄이고 안정적인 코드를 생산하기 위해 ES5부터 추가된 모드이다.
strict mode(엄격 모드)는 자바스크립트 언어의 문법을 보다 엄격히 적용해 오류를 발생시킬 가능성이 높거나, 자바스크립트 엔진의 최적화 작업에 문제를 일으킬 수 있는 코드에 대해 명식적인 에러를 발생시키는 모드이다.

장점:

- 예외를 발생시키는 일반적인 코딩 실수를 잡아낸다.
- 상대적으로 "안전하지 않은" 작업을 수행할 때 (전역 객체에 접근하는 것과 같은) 오류를 방지하거나 발생시킨다.
- 헷갈리거나 잘 모르는 기능을 비활성화한다.

단점:

- 엄격 모드와 비 엄격 모드가 혼합되었을 때, 예상과 다른 오류가 나오거나 발생하지 않을 수 있다.
- 엄격 모드는 일부 기능을 사용할 수 없게 막는다.

<br/>

### 27. Box model에 대해 설명해주세요.

모든 HTML 요소는 박스모양으로 구성되며, 이것을 박스 모델(box model)이라고 부른다. 박스 모델은 HTML 요소를 패딩(padding), 테두리(border), 마진(margin), 내용(content)로 구분한다.

1. content : 텍스트나 이미지가 들어있는 박스의 실질적 부분
2. padding : 내용과 테두리 사이 간격. 패딩은 눈에 보이지 않음
3. border : 내용과 패딩 주변을 감싸는 테두리
4. margin : 테두리와 이웃하는 요소 사이 간격. 마진은 눈에 보이지 않음

block 레벨의 엘리먼트에서는 content의 width, height 속성이 적용이 잘 되지만 inline 레벨 엘리먼트에서는 width, height 속성이 무시된다.

- block level : `<p>, <div>`, inline level : `<a>`

<br/>

### 28. Prototype이란? Prototype Chaining은?

자바스크립트의 모든 객체엔 숨김 프로퍼티 [[Prototype]]이 있는데, 이 프로퍼티는 객체나 null을 가리킨다. [[Prototype]]이 참조하는 객체를 '프로토타입’이라고 한다.

프로토타입은 어떤 객체의 상위(부모) 객체로 다른 객체에 공유 프로퍼티를 제공하며 객체 간 상속을 위해 사용된다. 프로토타입을 상속 받은 하위 객체는 자신의 상위 객체의 프로퍼티를 자신의 프로퍼티처럼 자유롭게 사용할 수 있다.

모든 객체는 하나의 프로토타입을 갖는다.([[Prototype]] 내부 슬로의 값이 null인 객체는 프로토타입이 없다) 모든 프로토타입은 생성자함수와 연결되어 있다.

- 객체는 `__proto__` 접근자 프로퍼티를 통해 프로토타입에 간접적으로 접근 할 수 있다.
- 프로토타입은 `constructor` 프로퍼티를 통해 생성자 함수에 접근할 수 있다.
- 생성자 함수는 `prototype`프로퍼티를 통해 프로토타입에 접근할 수 있다.

어떤 데이터의 **proto** 프로퍼티 내부에서 다시 **proto** 프로퍼티가 연쇄적으로 이어진것을 프로토타입 체인(prototype chain)이라 하고, 이 체인을 따라가며 검색하는 것을 프로토타입 체이닝(prototype chaining) 이라고 한다.

<br/>

### 29. forEach와 Map의 차이점은?

forEach 메서드와 map 메서드의 공통점은 자신을 호출한 배열의 모든 요소를 순회하면서 인수로 전달받은 콜백 함수를 반복 호출한다는 점이다. 차이점은 forEach 메서드는 언제나 undefined를 반환하고, map 메서드는 콜백 함수의 반환값들로 구성된 새로운 배열을 반환하는 차이가 있다. 즉, forEach 메서드는 단순히 반복문을 대체하기 위한 고차 함수이고, map 메서드는 요소값을 다른 값으로 매핑한 새로운 배열을 생성하기 위한 고차 함수이다.

<br/>

### 30. 화살표 함수와 일반함수의 차이점

화살표 함수는 function 키워드 대신 화살표를 사용해 간략하게 함수를 선언하는 방식이다.  
다른 함수와 다른 점은

1. 화살표 함수는 항상 익명함수로 정의한다.
2. 화살표 함수는 인스턴스를 생성할 수 없는 non-constructor로 프로토타입 프로퍼티가 없어 프로토타입도 생성하지 않는다.
3. 화살표 함수는 중복된 매개변수 이름을 선언할 수 없다.
4. 화살표 함수는 함수 자체의 this, arguments, super, new.target 바인딩을 갖지 않는다. 따라서 화살표 함수 내부에서 this, arguments, super, new.target을 참조하면 스코프 체인을 통해 상위 스코프의 this, arguments, super, new.target을 참조한다.  
   화살표 함수는 함수 자체의 this 바인딩을 갖지 않아 화살표 함수 내부에서 this를 참조하면 상위 스코프의 this를 그대로 참조한다. 이를 lexical this라고 한다.

<br/>

### 31. "==" 와 "==="의 차이

==는 동등 비교 연산자이고 ===는 일치 비교 연산자이다.
동등 비교(==)연산자는 좌항과 우항의 피연산자를 비교할 때 암묵적 타입 변환을 통해 타입을 일치시킨 후 같은 값인지 비교한다. 따라서 두 항의 피연산자의 타입이 달라도 값이 같다면 true를 반환한다. 일치 비교(===)연산자는 두 항의 피연산자가 타입과 값이 모두 같은 경우에만 true를 반환한다.

<br/>

### 32. 깊은복사, 얕은복사란?

얕은 복사란 바로 아래 단계의 값만 복사하는 방법이다. 즉 객체를 복사할 때 원래값과 복사된 값이 같은 참조를 가리키고 있다. 깊은 복사는 내부의 모든 값들을 하나하나 찾아서 전부 복사하는 방법. 객체안에 객체가 있을 경우에도 원본과의 참조가 완전히 끊어진 객체를 말한다.

<br/>

### 33. 크로스 브라우징이란?

크로스 브라우징이란 웹 페이지의 상호 호환성에 관한 것으로, 웹 페이지를 제작할 때, 모든 브라우저에서 개발자의 의도대로 올바르게 나오게 하는 것을 말한다.

브라우저별로 사용하는 렌더링 엔진이 다르고, 유저가 사용하는 기기의 사양이나 브라우저의 버전 차이 등으로 인해 일부 기능들이 모든 브라우저에서 동일하게 작동하지 않을 수 있으므로, 미리 크로스 브라우징을 통해 어떤 브라우저에서나 내용을 볼 수 있게 한다.

크로스 브라우징에서 중요한 것은 동일성이 아니고 동등성이다. 어떤 브라우저에서나 100% 똑같이 보이게 하는 것이 핵심이 아니고, 동등하게 어떤 브라우저에서든 페이지를 읽을 수 있도록 만드는 것이 핵심이다.

<br/>

### 34. HTTP 요청 메서드에 대해서 설명해주세요

HTTP 요청 메서드는 클라이언트가 서버에게 요청의 종류와 목적(리소스에 대한 행위)을 알리는 방법이다.

| HTTP 요청 메서드 |      종류      |         목적          | 페이로드 |
| :--------------: | :------------: | :-------------------: | :------: |
|       GET        | index/retrieve | 모든/특정 리소스 취득 |    X     |
|       POST       |     create     |      리소스 생성      |    O     |
|       PUT        |    replace     |  리소스의 전체 교체   |    O     |
|      PATCH       |     modify     |  리소스의 일부 수정   |    O     |
|      DELETE      |     delete     | 모든/특정 리소스 삭제 |    X     |

<br/>

### 35. 원시값과 참조값(array, object)의 차이점을 메모리 관점에서 설명해주세요.

데이터 타입을 원시 타입과 객체 타입으로 구분하는 이유는 두 타입이 근본적으로 다르기 때문이다. 원시 타입과 객체 타입은 크게 세 가지 측면에서 다르다.

1. 원시 타입의 값, 즉 원시 값은 변경 불가능한 값(immutable value)이다. 이에 비해 객체(참조)타입의 값, 즉 객체는 변경 가능한 값(mutable value)이다.

2. 원시 값을 변수에 할당하면 변수(확보된 메모리 공간)에는 실제 값(100, 실제로는 2진수)이 저장된다. 이에 비해 객체를 변수에 할당하면 변수(확보된 메모리 공간)에는 참조 값(메모리 주소, 0x00000613)이 저장된다.

3. 원시 값을 갖는 변수를 다른 변수에 할당하면 원본의 원시 값이 복사되어 전달된다. 이를 값에 의한 전달(pass by value)이라 한다. 이에 비해 객체를 가리키는 변수를 다른 변수에 할당하면 원본의 참조 값(메모리 주소, 0x00000613)이 복사되어 전달된다. 이를 참조에 의한 전달(pass by reference)이라 한다.

<br/>

### 36. 값에 의한 전달 / 참조에 의한 전달이 뭔가요?

값에 의한 전달이 뭔가요?

변수에 원시 값을 갖는 변수를 할당하면 할당받는 변수에는 할당되는 변수의 원시 값이 복사되어 전달된다. 이를 값에 의한 전달이라 한다.
할당받는 변수는 할당되는 변수의 원시 값이 복사되어 저장되지만 두 변수의 값은 다른 메모리 공간에 저장된 별개의 값이다. 서로 변수의 값을 변경해도 어떠한 영향도 주지 않는다.

참조에 의한 전달이 뭔가요?
객체를 가리키는 변수(원본)를 다른 변수(사본)에 할당하면 원본의 참조 값이 복사되어 전달된다. 이를 참조에 의한 전달이라 한다.
이렇게 원본을 사본에 할당하면 원본의 참조 값을 복사해서 사본에 저장한다. 이때 원본과 사본은 저장된 메모리 주소는 다르지만 동일한 참조 값을 지녀 동일한 객체를 가리킨다. 두 개의 식별자가 하나의 객체를 공유하는 것으로 어느 한쪽에서 객체를 변경하면 서로 영향을 주고 받는다.

<br/>

### 37. spread 문법을 사용할 때의 이점은 무엇이며 rest 문법과 다른 점은 무엇인가요?

spread 문법은 ES6에서 도입되어 하나로 뭉쳐 있는 여러 값들의 집합을 펼쳐서 개별적인 값들의 **목록**으로 만든다.

> spread 문법과 rest 문법은 반대의 개념

🌱spread 문법  
하나로 뭉쳐있는 여러 값들의 집합을 펼쳐서 개별적인 값들의 목록을 만드는 것

```js
console.log(...[1, 2, 3]); // 1, 2, 3
```

🌱rest 문법  
함수에 전달된 인수들의 목록을 배열로 전달 받기 위해 매개변수 앞에 ...을 붙이는 것

```js
function potato(...rest) {
  console.log(rest); // [1, 2, 3]
}
potato(1, 2, 3);
```

<br/>

### 38. 구조 분해 할당이 뭔가요?

이터러블 또는 객체를 구조 파괴하여 1개 이상의 변수에 개별적으로 할당하는 것

배열 구조 분해 할당

- 배열 구조 분해 할당문의 우변은 이터러블(반복 가능한 객체 - 대표적으로 배열)이어야 한다.
- 할당 기준은 배열의 인덱스다. (순서대로 할당)
- 배열 구조 분해 할당문의 좌변은 할당 받을 변수를 선언해야 한다. 변수를 배열 리터럴 형태로 선언한다.
- 변수의 개수와 이터러블의 요소 개수가 일치할 필요는 없다.

객체 구조 분해 할당

- 객체 구조 분해 할당문의 우변은 객체여야 한다.
- 할당 기준은 프로퍼티 키이며, 선언된 변수 이름과 프로퍼티 키가 일치 시 할당된다.
- 객체 구조 분해 할당문의 좌변은 할당 받을 변수를 선언해야 한다. 변수를 객체 리터럴 형태로 선언한다.
- 변수의 개수와 프로퍼티 개수가 일치할 필요는 없다.

<br/>

### 39. 타이머 함수 / 호출 스케줄링 / 디바운스 / 스로틀에 대해 설명해주세요.

호출 스케줄링이 무엇인가요?

함수를 명시적으로 호출하면 함수가 즉시 실행되는데, 함수를 명시적으로 호출하지 않고 일정 시간이 경과된 이후에 호출되도록 타이머 함수를 사용해 함수 호출을 예약하는 것을 호출 스케줄링이라 한다.

1. setTimeout / clearTimeout

   setTimeout 함수는 두 번째 인수로 전달받은 시간(ms, 1/1000초)으로 단 한 번 동작하는 타이머를 생성한다. 이후 타이머가 만료되면 첫 번째 인수로 전달받은 콜백 함수가 호출된다.

   setTimeout 함수가 반환한 타이머 id를 clearTimeout 함수의 인수로 전달하여 타이머를 취소할 수 있다.  
   즉, clearTimeout 함수는 호출 스케줄링을 취소한다.

2. setInterval / clearInterval

   setInterval 함수는 두 번째 인수로 전달받은 시간(ms, 1/1000초)으로 반복 동작하는 타이머를 생성한다. 이후 타이머가 만료될 때마다 첫 번째 인수로 전달받은 콜백 함수가 반복 호출된다. 이는 타이머가 취소될 때까지 계속된다.

   setInterval 함수가 반환한 타이머 id를 clearInterval 함수의 인수로 전달하여 타이머를 취소할 수 있다.  
   즉, clearInterval 함수는 호출 스케줄링을 취소한다.

scroll, resize, input, mousemove 같은 이벤트는 짧은 간격으로 연속해서 발생한다. 이러한 이벤트에 바인딩한 이벤트 핸들러는 과도하게 호출되어 성능에 문제를 일으킬 수 있다.  
**디바운스**와 **스로틀**은 짧은 시간 간격으로 연속해서 발생하는 이벤트를 그룹화해서 과도한 이벤트 핸들러의 호출을 방지하는 프로그래밍 기법으로, 디바운스와 스로틀을 사용해 해결할 수 있다.

디바운스는 짧은 시간 간격으로 이벤트가 연속해서 발생하면 이벤트 핸들러를 호출하지 않다가 일정 시간이 경과한 이후에 이벤트 핸들러가 한 번만 호출되도록 한다.

예를 들어, 텍스트 입력 필드에서 input 이벤트가 짧은 시간 간격으로 연속해서 발생할 때, input 이벤트 핸들러에서 Ajax 요청과 같은 무거운 처리를 수행한다면 사용자가 아직 입력을 완료하지 않았어도 불필요한 요청이 전송된다. 사용자가 입력을 완료했을 때 한 번만 요청을 전송하는 것이 바람직한데 입력을 완료했는지 정확히 알 수 없으므로 일정 시간 동안 값이 입력되지 않으면 입력이 완료된 것으로 간주한다.

디바운스는 첫번째 인자로 콜백함수, 두번째 인자로 시간(딜레이)를 전달 받아 딜레이보다 짧은 간격으로 이벤트가 발생하면 콜백함수의 타이머를 취소하고 재설정한다. 그러다 딜레이 동안 이벤트가 발생하지 않으면 한 번만 호출된다.

디바운스는 입력 필드 자동완성 UI 구현, 버튼 중복 클릭 방지 처리 등에 유용하게 사용된다.

![debouncing](https://user-images.githubusercontent.com/93918946/223635700-80a67aeb-1ab0-47c3-ad4e-e459d5fa5a50.gif)

<br/>

스로틀은 짧은 간격으로 이벤트가 연속해서 발생하더라도 일정 시간 간격으로 이벤트 핸들러가 최대 한 번만 호출되도록 한다. 즉, 스로틀은 짧은 간격으로 연속해서 발생하는 이벤트를 그룹화해서 일정 시간 단위로 이벤트 핸들러가 호출되도록 호출 주기를 만든다.

예를 들어, scroll 이벤트는 사용자가 스크롤할 때 짧은 시간 간격으로 연속해서 발생한다. 이처럼 과도한 이벤트 핸들러의 호출을 방지하기 위해 스로틀 함수는 이벤트를 그룹화해서 일정 시간 단위로 이벤트 핸들러가 호출되도록 호출 주기를 만든다.

스로틀은 scroll 이벤트 처리나 무한 스크롤 UI 구현 등에 유용하게 사용된다.

![throttle](https://user-images.githubusercontent.com/93918946/223635135-7923cb19-ce56-4305-a305-b90dc1eaaef8.gif)

<br/>

### 40. 함수형 프로그래밍이 뭔가요?

순수 함수를 통해 부수 효과를 최대한 억제해 오류를 피하고 프로그램의 안전성을 높이려는 프로그래밍 패러다임이다.  
함수형 프로그래밍에서는 어떤 외부 상태에 의존하지도 않고 변경하지도 않는, 즉 부수 효과가 없는 함수를 순수 함수라 하고, 외부 상태에 의존하거나 외부 상태를 변경하는, 즉 부수 효과가 있는 함수를 비순수 함수라고 한다.

순수 함수 : 외부 상태에 의존 X, 변경 X, 부수 효과 X  
비순수 함수 : 외부 상태에 의존 O, 변경 O, 부수 효과 O

<br/>

### 41. 모듈이 뭔가요?

일반적으로 기능을 기준으로 파일 단위로 분리된 재사용 가능한 코드 조각을 의미한다.

모듈 특징

- 모듈은 자신만의 파일스코프(모듈 스코프)를 가질 수 있어야 한다.
- 모듈은 공개가 필요한 자산에 한정하여 명시적으로 선택적 공개가 가능하다(export)
- 모듈 사용자는 모듈이 공개한 자산 중 일부 또는 전체를 선택해 자신의 스코프에서 재사용할 수 있다.

모듈 장점

- 코드의 단위를 명확히 분리하여 애플리케이션을 구성
- 재사용성이 좋아 개발 효율성과 유지보수성 높임

<br/>

### 42. 실행 컨텍스트에 대해 말해보세요

실행 컨텍스트는 자바스크립트 코드가 실행되는 환경이다. 모든 JavaScript 코드는 실행 컨텍스트 내부에서 실행된다고 생각하면 된다.

즉 함수가 실행되면 함수 실행에 해당하는 실행 컨텍스트가 생성되고, 자바스크립트 엔진에 있는 콜 스택에 차곡차곡 쌓인다.

그리고 가장 위에 쌓여있는 컨텍스트와 관련 있는 코드를 실행하면서(LIFO), 전체 코드의 환경과 순서를 보장하게 된다.
실행 컨텍스트는 식별자(변수, 함수, 클래스 등의 이름)를 등록하고 관리하는 스코프와 코드 실행 순서 관리를 구현한 내부 매커니즘으로, 실행 컨텍스트는 곧 자바스크립트의 핵심 원리다.

![실행 컨텍스트 스택](https://user-images.githubusercontent.com/107454269/224940335-5a3bfc4f-832e-4d21-8f8d-f848faa8e39b.jpg)

<br/>

### 43. "attribute"와 "property"의 차이점은 무엇인가요?

attribute는 **HTML 문서**에서 element에 추가적인 정보를 넣을 때 사용되는 **정적**인 요소이다.

```javascript
<div class='star'></div>
```

1. div는 element(요소)
2. class는 attribute
3. star는 class attribute의 value

property는 **HTML DOM**에서 attribute를 가리키는 **동적**인 요소이다. JavaScript는 정적인 문서인 HTML을 동적으로 동작하게 하는데, 그러한 동적인 속성을 부여하는 것이 property이다.

`<div class="star"></div>`를 DOM으로 표현하면

```javascript
Our DIV node
 | - nodeName = "DIV"
 | - className = "star"
 | - style
 ...
```

여기서 className이 property이다. HTML 문서 안에서 class는 attribute를 의미하지만 HTML DOM 안에서는 property를 의미한다고 볼 수 있다.

attribute는 HTML 문서에, property는 HTML DOM tree에 존재한다. attribute는 정적이며 변하지 않고 property는 동적으로 그 값이 변할 수 있다. 예를 들어 체크박스 태그가 있을 때 체크박스에 체크를 하면 attribute의 상태는 변하지 않지만 property의 상태는 checked로 변한다.

#### 참고 표

| attribute | property |
| --------- | -------- |
| HTML 문서 | HTML DOM |
| 정적      | 동적     |

<br/>

### 44. Function.prototype.bind을 설명하세요.

this 바인딩은 함수 호출 방식에 따라 동적으로 결정되는데 일반 함수에서 호출하면 전역 객체, 메서드 호출시에는 메서드를 호출한 객체, 생성자 함수 호출인 경우에는 생성자 함수가 생성할 인스턴스가 this 바인딩 대상이 된다.
Function.prototype.apply/call/bind의 경우에는 첫번째 인수로 전달한 객체가 this 바인딩 대상이 된다.

<br/>

### 45. event.target 과 event.currentTarget의 차이점은?

어떤 것을 반환하느냐의 차이인데, event.target은 부모로부터 이벤트가 위임되어 발생하는 자식의 위치, 내가 클릭한 자식 요소를 반환한다. 하지만 currentTarget은 이벤트가 부착된 부모의 위치를 반환한다.

<br/>

### 46. Map()과 Set()의 설명 및 차이점은?

Map은 key가 있는 데이터를 저장한다. 객체와 비슷한면이 있지만, 키값으로 다양한 타입을 허용한다. 예를들어 객체의 키는 무조건 문자형이지만, Map에는 키의 자료형에 제한이 없다. 주의 사항은 객체처럼 Map[key]형태를 사용하면 일반 객체로 취급하기 때문에 안쓰는게 좋다.

Set은 중복을 허용하지 않는 값을 모아두는 객체다. new Set(iterable) 이런식으로 선언을 한다. 요소의 유무를 판단할때 Array.find보다 Set.has()가 더 효율적이다.

<br/>

### 47. TDD란?

테스트 주도 개발이라는 뜻으로, 먼저 테스트 코드를 작성 한 후에 구현을 하는 방식이다.  
총 3가지의 절차가 있는데 실패 → 성공 → 리팩토링이 서로 꼬리를 물고 이뤄진다. TDD를 진행하면 테스트 케이스를 작성할 때 주로 작은 단위로 만들기 때문에 코드가 방대해지지 않고, 코드의 모듈화가 자연스럽게 잘 이루어진다.

<br/>

### 48. import와 require의 차이점은 무엇인가요?

import와 require 모두 외부 라이브러리나 다른 파일을 불러오는 동일한 목적을 가지고있다.  
import의 경우 ES6에서 도입되었기때문에 babel과 같은 ES6 코드를 변환해주는 도구 없이는 사용하지못한다.  
사용방법은 import는 그냥 바로 키워드를 사용하여 직관적으로 모듈을 불러 올 수 있지만  
require은 다른 변수를 할당하듯이 불러와줘야한다.

```javascript
import moment from 'moment';
const moment = require('moment');
```

<br/>

### 49. MVC, MVVM 모델에 대해 설명하세요

MVC 모델은 애플리케이션을 모델 + 뷰 + 컨트롤러로 분리하는 아키텍처이다.  
모델은 데이터 및 데이터를 처리하는 부분이고, view는 사용자에게 보여지는 UI 부분이다. 컨트롤러는 사용자의 입력을 받고 처리하는 부분이다.

1. 사용자의 요청이 Controller에 들어옵니다.
2. Controller는 요청에 맞게 Model을 업데이트합니다.
3. Controller에서 업데이트된 Model을 나타내줄 View를 선택합니다.
4. View는 업데이트된 Model을 사용자에게 보여주기 위해 UI 데이터를 업데이트 합니다.

장점  
가장 단순한 패턴으로 여러 개발 분야에서 보편적으로 사용되는 디자인 패턴입니다.  
단점  
View와 Model사이의 의존성이 높습니다. 이는 앱이 커질수록 유지보수가 어려워집니다.

MVVM 모델은 애플리케이션을 모델 + 뷰 + 뷰모델로 분리하는 아키텍처이고, 모델과 뷰는 MVC와 동일하다.  
뷰모델은 뷰를 표현하기 위해 만든 뷰를 위한 모델이다. 뷰를 나타내 주기 위한 모델이자, 뷰를 나타내기 위해 데이터 처리를 하는 부분이다.

1. 사용자의 Action들은 View를 통해 들어옵니다.
2. View에 Action이 들어오면 ViewModel에 Action을 전달합니다.
3. ViewModel은 Model에게 데이터를 요청합니다.
4. Model은 ViewModel에게 요청받은 데이터를 응답합니다.
5. ViewModel은 응답 받은 데이터를 가공하여 저장합니다.
6. View는 Data Binding을 이용해 UI를 갱신시킵니다.

장점  
테스트 및 확장 용이성이 증가하고, 데이터 바인딩을 사용한다면 View와 ViewModel사이의 의존성 또한 없어진다.  
단점  
ViewModel의 설계가 쉽지 않다.

<br/>

### 50. Flex 속성을 설명해주세요.

Flexbox란 기존 컨텐츠를 수평으로 배치할 때, float나 inline-block으로 마크업할때의 불편함을 쉽게 해결할 수 있도록 추가된 기능이다. 다양한 디바이스 환경에서 언제나 똑같은 레이아웃을 유지시켜줌으로써 반응형 웹 사이트에 유용하게 쓰인다. Flex는 컨텐츠를 감싸는 상위 부모요소인 Flex Container와 각 컨텐츠들인 자식요소 Flex Item으로 구성되어있다. Flexbox css 적용방법은 부모요소인 container에 display:flex를 선언하면 된다. Flex Container에는 전체적인 정렬과 관련된 속성인 display, flex-direction, align-items, flex-wrap 같은 속성을 정의하고, 자식요소인 flex item에는 flex-grow, flex-shrink 같은 크기나 순서 같은 속성을 정의한다.

<br/>
